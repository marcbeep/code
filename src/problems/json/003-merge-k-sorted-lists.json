{
  "id": 3,
  "title": "Merge K Sorted Lists",
  "list": "blind75",
  "category": "Linked List",
  "topics": [
    "Linked List",
    "Divide and Conquer",
    "Heap (Priority Queue)",
    "Merge Sort"
  ],
  "difficulty": "Hard",
  "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
  "constraints": [
    "k == lists.length",
    "0 <= k <= 104",
    "0 <= lists[i].length <= 500",
    "-104 <= lists[i][j] <= 104",
    "lists[i] is sorted in ascending order",
    "The sum of lists[i].length will not exceed 104"
  ],
  "testCases": [
    {
      "input": {
        "lists": [
          [1, 4, 5],
          [1, 3, 4],
          [2, 6]
        ]
      },
      "output": [1, 1, 2, 3, 4, 4, 5, 6],
      "explanation": "The merged list contains all nodes from the three input lists in sorted order."
    },
    {
      "input": { "lists": [] },
      "output": null,
      "explanation": "Empty list of lists returns null."
    },
    {
      "input": { "lists": [null] },
      "output": null,
      "explanation": "List containing only null returns null."
    }
  ],
  "solution": {
    "code": "from typing import List, Optional\nfrom heapq import heappush, heappop\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n    # Create a min heap\n    min_heap = []\n    \n    # Push the first node of each list into the heap\n    for i, list_head in enumerate(lists):\n        if list_head:\n            heappush(min_heap, (list_head.val, i, list_head))\n    \n    # Create a dummy head for the result list\n    dummy = ListNode(0)\n    current = dummy\n    \n    # While there are nodes in the heap\n    while min_heap:\n        # Get the node with smallest value\n        val, i, node = heappop(min_heap)\n        \n        # Add it to the result list\n        current.next = node\n        current = current.next\n        \n        # If the list has more nodes, push the next node\n        if node.next:\n            heappush(min_heap, (node.next.val, i, node.next))\n    \n    return dummy.next",
    "explanation": "This solution uses a min heap to efficiently merge k sorted lists:\n1. Create a min heap to keep track of the smallest node from each list\n2. Push the first node of each non-empty list into the heap\n3. Repeatedly extract the smallest node from the heap and add it to the result list\n4. If the extracted node has a next node, push that into the heap\n\nThe time complexity is O(N log k) where N is the total number of nodes and k is the number of lists. The space complexity is O(k) for the heap.\n\nNote: The ListNode class includes a custom __lt__ method to enable comparison in the heap."
  }
}
