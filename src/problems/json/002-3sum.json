{
  "id": 2,
  "title": "3Sum",
  "list": ["blind75", "neetcode150", "leetcode150"],
  "category": "Array",
  "topics": ["Array", "Two Pointers", "Sorting"],
  "difficulty": "Medium",
  "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.",
  "constraints": ["3 <= nums.length <= 3000", "-105 <= nums[i] <= 105"],
  "testCases": [
    {
      "input": { "nums": [-1, 0, 1, 2, -1, -4] },
      "output": [
        [-1, -1, 2],
        [-1, 0, 1]
      ],
      "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
    },
    {
      "input": { "nums": [] },
      "output": [],
      "explanation": "Empty array has no triplets."
    },
    {
      "input": { "nums": [0] },
      "output": [],
      "explanation": "Array with less than 3 elements has no triplets."
    }
  ],
  "solution": {
    "code": "def three_sum(nums: list[int]) -> list[list[int]]:\n    # Sort the array to help with duplicate handling\n    nums.sort()\n    result = []\n    \n    # Iterate through each number as potential first element\n    for i in range(len(nums) - 2):\n        # Skip duplicates for first element\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n            \n        # Use two pointers for second and third elements\n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                # Skip duplicates for second element\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                # Skip duplicates for third element\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
    "explanation": "This solution uses a two-pointer approach after sorting the array:\n1. Sort the array to help with duplicate handling and to use two-pointer technique\n2. For each number as the first element, use two pointers to find pairs that sum to the negative of the first number\n3. Skip duplicates to avoid duplicate triplets\n4. Move pointers based on whether the current sum is less than or greater than zero\n\nThe time complexity is O(nÂ²) where n is the length of the array. The space complexity is O(1) if we don't count the output array, or O(n) if we do."
  }
}
