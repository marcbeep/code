{
  "id": 2,
  "title": "Reverse Linked List",
  "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
  "solution": {
    "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head: ListNode) -> ListNode:\n    # Initialize pointers\n    prev = None\n    curr = head\n    \n    # Iterate through the list\n    while curr:\n        # Store the next node\n        next_node = curr.next\n        \n        # Reverse the link\n        curr.next = prev\n        \n        # Move pointers forward\n        prev = curr\n        curr = next_node\n    \n    # prev will be the new head\n    return prev",
    "explanation": "This solution uses an iterative approach to reverse the linked list. We use three pointers:\n1. prev: points to the previous node (initially None)\n2. curr: points to the current node (initially head)\n3. next_node: points to the next node\n\nFor each node, we:\n1. Store the next node\n2. Reverse the link by pointing current node's next to previous node\n3. Move prev and curr pointers forward\n\nThe time complexity is O(n) as we visit each node once, and space complexity is O(1) as we only use a constant amount of extra space."
  },
  "category": "Linked List",
  "difficulty": "Easy",
  "testCases": [
    {
      "input": {
        "head": [1, 2, 3, 4, 5]
      },
      "output": [5, 4, 3, 2, 1],
      "explanation": "The linked list is reversed, so 1->2->3->4->5 becomes 5->4->3->2->1"
    },
    {
      "input": {
        "head": [1, 2]
      },
      "output": [2, 1],
      "explanation": "The linked list is reversed, so 1->2 becomes 2->1"
    },
    {
      "input": {
        "head": []
      },
      "output": [],
      "explanation": "An empty list remains empty"
    }
  ],
  "constraints": [
    "The number of nodes in the list is in the range [0, 5000]",
    "-5000 <= Node.val <= 5000"
  ],
  "topics": ["Linked List", "Recursion"],
  "list": "blind75"
}
